# Database design

[Ning] I've added comments to the doc based on my understanding of Django
framework. The autoincrement id fields are not necessary as they are handled
automatically.

## User Table
(Note, use Google auth APIs - we don't want to do password management, etc)

  - `user_id` - key, autoincrement
  - `username` - Name of user

[Ning] Django's default User model contains username, email, password, 
first_name, and last_name fields - should be sufficient for this project. We 
derive from it to create a custom user model (but not adding any new field) to 
facilitate future development.

## User Access Table
Provides a mapping of which users have access to which clusters. [Ning] user A 
could use a cluster created by user B if permission is given. This 
relationship is a fairly straight-forward. Therefore it is added to the 
Cluster table as a 'authorised users' field. In practice, Django generates an 
extra table any way to handle such many-to-many relationship.

  - `user_id` - key into User Table
  - `cluster_id` - key into Cluster Table

## [Ning] Credential table
Save users cloud credentials. It is fairly complex to programmatically set up cloud credentials (e.g. create a service account on GCP and assign it sufficient permissions to allow working VMs as HPC clusters). We ask user to generate the credentials, either from command line or via web consoles, and copy/paste the credential details to the web form. It is fairly simple to validate credentials.

  - `name` - name of the credential
  - `owner` - who owns this credential
  - `cloud_provider` - Which provider
  - `detail` - text of the credential (e.g. for GCP in JSON format) 
  - `validated` - flag whether this credential is validated

## Cluster Table
[Ning] A user can have one cluster per cloud provider. Each cluster can have
multiple node types.

  - `cluster_id` - key, autoincrement?
  - `name` - name of the cluster
  - `internal_name` - cluster name generated by CitC
  - `cloud_provider` - Which provider
  - `credentials` - key into Credential table
  - `instance_types` - VM instance types ('shape:count,shape:count...') [ning] constraints of node types can be imposed by 'Cluster in the cloud'. It is not easy to include the 'count' values in this database table. A separate table 'ClusterInstanceType' can be used.
  - `region` - Cloud region
  - `zone` - Cloud zone
  - `headnode_ip` - Cluster Head Node IP addr
  - `status` - [Ning] current status of the cluster, e.g. ready, stopped, deleted, as can be updated by the backend 

## Cluste Intance Type Table
  - `cluster` - key into Cluster table
  - `instanace_type` - key into MachineType table
  - `count` - maximum number of such node type to use in the cluster

## Benchmark Table

[Ning] A benchmark is an unique combination of an application binary and an 
input dataset, e.g. a OpenFOAM v7 compiled by xxx complier with yyy MPI library
running the MotorBike 22 million dataset.

  - `bench_id` - key, autoincrement?
  - `name` - Common name of benchmark + dataset
  - `app_name` - Name of benchmark application
  - `dataset` - key into Dataset table
  - `script_dir` - directory of target scripts [Ning] we can use the unique ID field in a directory structure when working with data files (both inputs and results) 

## Benchmark Results Table

[Ning] This represents a single run of a benchamrk - run-time settings and
results can be saved in this table.

  - `run_id` - key, autoincrement?
  - `bench_id` - key into Benchmark table
  - `cluster_id` - key into Cluster table
  - `instance_types` - Type of VM instance
  - `arch` - Architecture of the processors (some machine type may have multiple architectures)
  - `nnodes` - Number of Nodes used
  - `ranks_per_node` - Number of MPI ranks per node
  - `threads_per_rank` - Number of threads per MPI rank [Ning] reserved for future use to support hybrid code
  - `state` - "Waiting, Installing, Preparing, Running, Finished, Error", etc.
  - `log text` - Truncated Output from running the job [Ning] may be better to store logs in files, using unique file names containing the ID of this benchmark.
  - `result_units` - Units for results (seconds, itrs/sec, etc)
  - `result_value` - Benchmark results value
  - `runtime` - Benchmark result runtime (may duplicate `result_value` in some cases)

## [Ning] Dataset Table

This represents a single input dataset. One dataset may be used by multiple 
benchmarks (two applications, or different versions of the same application 
can can use the same dataset); one application installation can run mutiple
dataset. This table can take care of such logic.

## [Ning] Other tables

In Django, it is fairly easy to create additional models to represent small
objects such as machine types, cloud providers, compilers, MPI libraries. We
benefit from Django's admin site to easily manage these fields. 
